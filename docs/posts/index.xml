<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Yonh&#39;s Blog</title>
    <link>/posts/</link>
    <description>Recent content in Posts on Yonh&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Wed, 12 Dec 2018 07:06:28 +0000</lastBuildDate>
    
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ffmpeg常用命令记录</title>
      <link>/posts/ffmpeg-commands/</link>
      <pubDate>Wed, 12 Dec 2018 07:06:28 +0000</pubDate>
      
      <guid>/posts/ffmpeg-commands/</guid>
      <description>

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#### m4a转mp3
ffmpeg -i 许巍2018-12-08慕司之夜-深圳站_录音.m4a -acodec libmp3lame -ab 128k output7.mp3

#### 截取音频片段
# -ss开始 -t截取时间 -y 覆盖文件
ffmpeg -y -i 许巍2018-12-08慕司之夜-深圳站_录音.m4a -acodec copy -ss 00:02:11 -t 00:06:10 output.m4a

#### 单独提取音频(去掉视频)
ffmpeg -i input.mp4 -f mp3 -vn output.mp3
ffmpeg -i input.mp4 -acodec copy -vn output.mp3

#### 单独提取视频(去掉声音)
ffmpeg -i input.mp4 -vcodec copy -an output.mp4

#### 获取视频信息输出json格式
ffprobe -v quiet -print_format json -show_format -show_streams 视频.avi

#### 淡入淡出
## m4a总长度是67.5秒，从66秒开始fade out效果1.5秒。
ffmpeg -i output.m4a -filter_complex afade=t=out:st=66:d=1.5 6075fade.m4a
## 分割视频并给分割出的视频开头和结尾做淡入淡出效果
ffmpeg -ss 20 -i p.mp4 -vf &amp;quot;fade=in:0:50,fade=out:450:50&amp;quot; -t 20 Ok.mp4
ffmpeg -ss 20 -i p.mp4 -vf &amp;quot;fade=in:0:d=1,fade=out:st=29:d=1&amp;quot; -t 20 OK.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;其他&#34;&gt;其他&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#### ffmpeg做水面倒影效果
ffmpeg -i input.avi -vf &amp;quot;split[a][b];[a]pad=iw:ih*2[a];[b]vflip[b];[a][b]overlay=0:h&amp;quot; output.avi
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用Karabiner将其他键盘配置为类似HHKB的布局</title>
      <link>/posts/set-keyboard-to-hhkb-style/</link>
      <pubDate>Sun, 21 Oct 2018 16:01:05 +0000</pubDate>
      
      <guid>/posts/set-keyboard-to-hhkb-style/</guid>
      <description>

&lt;h1 id=&#34;使用karabiner将其他键盘配置为类似hhkb的布局&#34;&gt;使用Karabiner将其他键盘配置为类似HHKB的布局&lt;/h1&gt;

&lt;h4 id=&#34;背景说明&#34;&gt;背景说明&lt;/h4&gt;

&lt;p&gt;配置键盘： &lt;code&gt;Niz 84键无线蓝牙静电容键盘&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;事实上的配置应该是&lt;code&gt;HHKB lite&lt;/code&gt;的布局，因为非lite版的HHKB键盘左下角都没有&lt;code&gt;fn&lt;/code&gt;键&lt;/p&gt;

&lt;p&gt;但是我用惯了&lt;code&gt;fn&lt;/code&gt;在左下角的方式，因此我会把HHKB的&lt;code&gt;left_opt&lt;/code&gt;替换为&lt;code&gt;fn&lt;/code&gt;,其他键盘类似。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pqrs.org/osx/karabiner&#34;&gt;下载Karabiner-Elements&lt;/a&gt;, &lt;a href=&#34;https://pqrs.org/osx/karabiner/json.html#typical-complex_modifications-examples-change-right-shift-x2-to-mission-control&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;任务&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;caps_lock&lt;/code&gt; to &lt;code&gt;fn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; to &lt;code&gt;Esc&lt;/code&gt; , &lt;code&gt;Home&lt;/code&gt; to &lt;code&gt;~&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;HHKB Arrow Mode (fn + semicolon/slash/open_bracket/quote to arrow keys, etc)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fn + control + 上下左右不能切换屏幕&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;学习到的知识&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在哪里保存&lt;code&gt;karabiner&lt;/code&gt;映射规则脚本&lt;/li&gt;
&lt;li&gt;映射规则基本语法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解决方案&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;optional&lt;/code&gt;添加&lt;code&gt;control&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;视频&#34;&gt;视频&lt;/h4&gt;

&lt;p&gt;&lt;object width=&#34;425&#34; height=&#34;344&#34;&gt;&lt;param name=&#34;movie&#34; value=&#34;https://www.youtube.com/v/R0OHiyxM2A4&amp;hl=en&amp;fs=1&#34;&gt;&lt;/param&gt;&lt;param name=&#34;allowFullScreen&#34; value=&#34;true&#34;&gt;&lt;/param&gt;&lt;embed src=&#34;https://www.youtube.com/v/R0OHiyxM2A4&amp;hl=en&amp;fs=1&#34; type=&#34;application/x-shockwave-flash&#34; allowfullscreen=&#34;true&#34; width=&#34;425&#34; height=&#34;344&#34;&gt;&lt;/embed&gt;&lt;/object&gt;&lt;/p&gt;

&lt;p&gt;规则脚本放在&lt;code&gt;~/.config/karabiner/assets/complex_modifications&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;title&amp;quot;: &amp;quot;Happy Hacking Keyboard Compatible Mode (rev 2)&amp;quot;,
  &amp;quot;rules&amp;quot;: [
    {
      &amp;quot;description&amp;quot;: &amp;quot;HHKB Arrow Mode (fn + semicolon/slash/open_bracket/quote to arrow keys, etc)&amp;quot;,
      &amp;quot;manipulators&amp;quot;: [
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;semicolon&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ],
              &amp;quot;optional&amp;quot;: [
                &amp;quot;caps_lock&amp;quot;,
                &amp;quot;option&amp;quot;,
                &amp;quot;command&amp;quot;,
                &amp;quot;control&amp;quot;,
                &amp;quot;shift&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;key_code&amp;quot;: &amp;quot;left_arrow&amp;quot;
            }
          ]
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;slash&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ],
              &amp;quot;optional&amp;quot;: [
                &amp;quot;caps_lock&amp;quot;,
                &amp;quot;option&amp;quot;,
                &amp;quot;command&amp;quot;,
                &amp;quot;control&amp;quot;,
                &amp;quot;shift&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;key_code&amp;quot;: &amp;quot;down_arrow&amp;quot;
            }
          ]
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;open_bracket&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ],
              &amp;quot;optional&amp;quot;: [
                &amp;quot;caps_lock&amp;quot;,
                &amp;quot;option&amp;quot;,
                &amp;quot;command&amp;quot;,
                &amp;quot;control&amp;quot;,
                &amp;quot;shift&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;key_code&amp;quot;: &amp;quot;up_arrow&amp;quot;
            }
          ]
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;quote&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ],
              &amp;quot;optional&amp;quot;: [
                &amp;quot;caps_lock&amp;quot;,
                &amp;quot;option&amp;quot;,
                &amp;quot;command&amp;quot;,
                &amp;quot;control&amp;quot;,
                &amp;quot;shift&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;key_code&amp;quot;: &amp;quot;right_arrow&amp;quot;
            }
          ]
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;l&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ],
              &amp;quot;optional&amp;quot;: [
                &amp;quot;caps_lock&amp;quot;,
                &amp;quot;control&amp;quot;,
                &amp;quot;option&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;key_code&amp;quot;: &amp;quot;page_up&amp;quot;
            }
          ]
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;period&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ],
              &amp;quot;optional&amp;quot;: [
                &amp;quot;caps_lock&amp;quot;,
                &amp;quot;control&amp;quot;,
                &amp;quot;option&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;key_code&amp;quot;: &amp;quot;page_down&amp;quot;
            }
          ]
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;k&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ],
              &amp;quot;optional&amp;quot;: [
                &amp;quot;caps_lock&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;key_code&amp;quot;: &amp;quot;home&amp;quot;
            }
          ]
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;comma&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ],
              &amp;quot;optional&amp;quot;: [
                &amp;quot;caps_lock&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;key_code&amp;quot;: &amp;quot;end&amp;quot;
            }
          ]
        }
      ]
    },
    {
      &amp;quot;description&amp;quot;: &amp;quot;HHKB Media Key Mode (fn + asdf to Volume down/up/mute, eject) (rev 2)&amp;quot;,
      &amp;quot;manipulators&amp;quot;: [
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;a&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ],
              &amp;quot;optional&amp;quot;: [
                &amp;quot;any&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;consumer_key_code&amp;quot;: &amp;quot;volume_decrement&amp;quot;
            }
          ]
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;s&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ],
              &amp;quot;optional&amp;quot;: [
                &amp;quot;any&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;consumer_key_code&amp;quot;: &amp;quot;volume_increment&amp;quot;
            }
          ]
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;d&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ],
              &amp;quot;optional&amp;quot;: [
                &amp;quot;any&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;consumer_key_code&amp;quot;: &amp;quot;mute&amp;quot;
            }
          ]
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;f&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ],
              &amp;quot;optional&amp;quot;: [
                &amp;quot;any&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;consumer_key_code&amp;quot;: &amp;quot;eject&amp;quot;
            }
          ]
        }
      ]
    },
    {
      &amp;quot;description&amp;quot;: &amp;quot;Map fn + i, o, p  to F13, F14, F15.&amp;quot;,
      &amp;quot;manipulators&amp;quot;: [
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;i&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;key_code&amp;quot;: &amp;quot;f13&amp;quot;
            }
          ]
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;o&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;key_code&amp;quot;: &amp;quot;f14&amp;quot;
            }
          ]
        },
        {
          &amp;quot;type&amp;quot;: &amp;quot;basic&amp;quot;,
          &amp;quot;from&amp;quot;: {
            &amp;quot;key_code&amp;quot;: &amp;quot;p&amp;quot;,
            &amp;quot;modifiers&amp;quot;: {
              &amp;quot;mandatory&amp;quot;: [
                &amp;quot;fn&amp;quot;
              ]
            }
          },
          &amp;quot;to&amp;quot;: [
            {
              &amp;quot;key_code&amp;quot;: &amp;quot;f15&amp;quot;
            }
          ]
        }
      ]
    }
  ]
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>配置Rime输入法</title>
      <link>/posts/rime-config/</link>
      <pubDate>Tue, 16 Oct 2018 06:31:42 +0000</pubDate>
      
      <guid>/posts/rime-config/</guid>
      <description>

&lt;h3 id=&#34;环境&#34;&gt;环境&lt;/h3&gt;

&lt;p&gt;Ubuntu 18.04&lt;/p&gt;

&lt;h3 id=&#34;目标&#34;&gt;目标&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;配置rime输入法，添加双拼方案&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 安装rime和双拼方案
sudo apt install -y fcitx-rime librime-data-double-pinyin

# 创建配置文件 `~/.config/fcitx/rime/default.custom.yaml`并配置。
echo &amp;quot;\
# default.custom.yaml
# save it to:
#   ~/.config/ibus/rime   (linux ibus)
#   ~/.config/fcitx/rime  (linux fcitx)
#   ~/Library/Rime        (macos)
#   %APPDATA%\Rime        (windows)

patch:
  schema_list:
    - schema: luna_pinyin          # 朙月拼音
    - schema: luna_pinyin_simp     # 朙月拼音 简化字模式
    - schema: luna_pinyin_tw       # 朙月拼音 臺灣正體模式
    - schema: terra_pinyin         # 地球拼音 dì qiú pīn yīn
    - schema: bopomofo             # 注音
    - schema: jyutping             # 粵拼
    - schema: cangjie5             # 倉頡五代
    - schema: cangjie5_express     # 倉頡 快打模式
    - schema: quick5               # 速成
    - schema: wubi86               # 五笔 86
    - schema: wubi_pinyin          # 五笔拼音混合輸入
    - schema: double_pinyin        # 自然碼雙拼
    - schema: double_pinyin_mspy   # 微軟雙拼
    - schema: double_pinyin_abc    # 智能 ABC 雙拼
    - schema: double_pinyin_flypy  # 小鶴雙拼
    - schema: wugniu        # 吳語上海話（新派）
    - schema: wugniu_lopha  # 吳語上海話（老派）
    - schema: sampheng      # 中古漢語三拼
    - schema: zyenpheng     # 中古漢語全拼
    - schema: ipa_xsampa    # X-SAMPA 國際音標
    - schema: emoji         # emoji 表情
&amp;quot; &amp;gt; ~/.config/fcitx/rime/default.custom.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重启&lt;code&gt;fcitx&lt;/code&gt;，&lt;code&gt;Ctrl + ~&lt;/code&gt; 调出选择输入法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lisp解释器的代码分析过程记录</title>
      <link>/posts/lisp-interpreter/</link>
      <pubDate>Fri, 01 Jul 2016 00:54:25 +0000</pubDate>
      
      <guid>/posts/lisp-interpreter/</guid>
      <description>

&lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;

&lt;p&gt;由于文章不是同一时间写的，而是不断的往上加内容，而且我觉得这样完整的记录我的整个分析记录是非常不错的方式，对于我的混乱写作感到抱歉请见谅，我只是遵循着心中的言语而作的记录&lt;/p&gt;

&lt;p&gt;五一期间，打算给自己整天的时间好好看看《实用Common Lisp编程》，却是意外的发现了篇非常棒的lisp入门文章-过河卒的（记得以前我是看过了，但是当时不知道是觉得难还是其他什么原因，没继续看），里面从基础直到讲解编写一个lisp解释器的实现（文章是这么说的），已经忘了怎么能找到的了，回想起来，将其称之为缘分吧，我无法解释这些我喜欢的东西能这么有幸与我相遇(不仅仅是编程)，也是我为什么需要写文的原因，因为我会忘了一切，几乎就没记住过很多东西，我讨厌让我的脑子很累(我非常刻意的逃避一些东西,请原谅我的记性，因为我不会记得我不感兴趣的东西，因为那太累了[借口？我想是的])&lt;/p&gt;

&lt;p&gt;回到这篇文章，看它来入门真的非常不错，我看到讲到Lisp世界七个公理的部分，我搜索了下&amp;rdquo;Lisp七个公理&amp;rdquo;, 有幸找到了维基教科书里面的Lisp入门，这网站非常好，能够生成电子书以下载，&lt;/p&gt;

&lt;p&gt;网站地址在此: &lt;a href=&#34;http://zh.wikibooks.org/wiki/Lisp_%E5%85%A5%E9%96%80&#34;&gt;Lisp 入門&lt;/a&gt;
将其10章看完，感觉我之前看到《实用Common Lisp编程》实在不该（这个入门比较简单，能比较好的理解lisp一些基本知识），对比这3篇我看过的入门文章，我不想去说哪个好，我本身没什么本事，没那个资格评判它们(当然，我是认为该尊重自己内心的想法就好[它既不正确也不错误]，它是怎么就怎么),它们给了我不同的视角去了解lisp,让我发现，哦，原来入门文章可以这么写(今天刚看了个视频，讲的是有名的IT词汇的解释，里面讲课的方式就非常棒，事先弄出一个画面，然后拿着各种接下来的操作的纸条，场景来继续下面的讲课，非常生动)
下面是过河卒的lisp入门文章链接
&lt;a href=&#34;http://www.cnblogs.com/suiqirui19872005/archive/2007/12/05/984517.html&#34;&gt;http://www.cnblogs.com/suiqirui19872005/archive/2007/12/05/984517.html&lt;/a&gt;
当然这个解释器可能是出自这里的
&lt;a href=&#34;http://daiyuwen.freeshell.org/gb/rol/roots_of_lisp.html&#34;&gt;http://daiyuwen.freeshell.org/gb/rol/roots_of_lisp.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文章基本看完了，剩下下面的lisp解释器实现实在是看不懂，于是将我的下班空闲时间都用来研究它了，以下是笔记&lt;/p&gt;

&lt;p&gt;2014-05-06 00:52:12&lt;/p&gt;

&lt;p&gt;需要注意的是，文章后面2章顺序颠倒了，而且函数pair实现最后一行&lt;code&gt;(pair (cdr) (cdr y))))))&lt;/code&gt;应改为&lt;code&gt;(pair (cdr x) (cdr y))))))&lt;/code&gt;,具体的&lt;code&gt;eval&lt;/code&gt;，&lt;code&gt;assoc&lt;/code&gt;函数应该改个名字，我不知道common lisp标准里面有没有它们(应该是有吧,没去研究),反正我是提示了已存在函数声明，所以我改成了加个2的名字&lt;/p&gt;

&lt;p&gt;-————完整程序 迷糊的摘录了(拷贝的)，学习中修正错误&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun assoc2 (x y)
  (cond ((eq (caar y) x) (cadar y))
        (t (assoc x (cdr y)))))

&amp;gt; (assoc2 &#39;a &#39;((a 1) (b 2)))
1

(defun pair (x y)
  (cond ((and (null x) (null y)) &#39;())
        ((and (not (atom x)) (not (atom y)))
         (cons (list (car x) (car y))
               (pair (cdr x) (cdr y))))))
&amp;gt; (pair &#39;(1 2) &#39;(A B))
((1 A) (2 B))


(defun eval2 (e a)
  (cond
    ((atom e) (assoc2 e a))    ;第一段
    ((atom (car e))        ;第二段
     (cond
       ((eq (car e) &#39;quote) (cadr e))
       ((eq (car e) &#39;atom)  (atom   (eval2 (cadr e) a)))
       ((eq (car e) &#39;eq)    (eq     (eval2 (cadr e) a)
                                    (eval2 (caddr e) a)))
       ((eq (car e) &#39;car)   (car    (eval2 (cadr e) a)))
       ((eq (car e) &#39;cdr)   (cdr    (eval2 (cadr e) a)))
       ((eq (car e) &#39;cons)  (cons   (eval2 (cadr e) a)
                                    (eval2 (caddr e) a)))
       ((eq (car e) &#39;cond)  (evcon (cdr e) a))
       (&#39;t (eval (cons (assoc2 (car e) a)
                        (cdr e))
                  a))))     ;第二段结束
    ((eq (caar e) &#39;label)
     (eval (cons (caddar e) (cdr e))
            (cons (list (cadar e) (car e)) a)))
    ((eq (caar e) &#39;lambda)
     (eval (caddar e)
            (append (pair (cadar e) (evlis (cdr  e) a))
                     a)))))

(defun evcon (c a)
  (cond ((eval2 (caar c) a)
         (eval2 (cadar c) a))
        (&#39;t (evcon (cdr c) a))))

(defun evlis (m a)
  (cond ((null m) &#39;())
        (&#39;t (cons (eval2  (car m) a)
                  (evlis (cdr m) a)))))

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;; 基本知识
; 1，lisp七个基本操作符，caar，cadr等函数的理解，
-------------------我写的程序----------------
; 依赖函数
(defun assoc2 (x y)
  (cond ((eq (caar y) x) (cadar y))
        (t (assoc2 x (cdr y)))))
&amp;gt;(assoc2 &#39;a &#39;((a x) (b y)))
x 
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;第一段&lt;/p&gt;

&lt;p&gt;刚看时就感觉在看天书啊，根本看不懂每一句为什么要这么写，有什么意义，所以刚开始看的时候是一句句分析，代入分析一句句代码到底要干什么，为什么要这么写先没考虑，后面不知道怎么想到的方法，将代码从大块划分成小块，然后在小块里面找最内层的表达式，然后编写函数模拟里面的代码，一点一点的扩大范围，简单的说就是看着代码，然后编写一个和原代码很像的一段代码，理解后再替换成源代码，这么就理解了该段代码到底要做什么&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun f1 (e a)

(cond ((atom e) (assoc2 e a))))

&amp;gt;(f1 &#39;a &#39;((a 1) (b 2)))

1

&amp;gt;(f1 &#39;a &#39;((a (q 1) (b 2))))

(Q 1)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当参数e为原子的时候，返回a列表中a元素后面的元素,读懂这句其实还是不大清楚要做什么，先接着看下去&lt;/p&gt;

&lt;p&gt;第二段&lt;/p&gt;

&lt;p&gt;第二段程序比较长，刚开始我先试着读它的结构，发现，它是读取 参数e中第一个元素，判断其值是否是七个基本操作符&lt;code&gt;(quote,atom,eq,car,cdr,cons,cond)&lt;/code&gt;,执行不同操的操作&lt;/p&gt;

&lt;p&gt;因为我实在难以看懂整个程序，我希望我将它们分解，然后一步一步的实现它们，以此来弄懂程序在做些什么，所以会写很多个看似无关的函数，但它们是我了解整个程序的很重要一步&lt;/p&gt;

&lt;p&gt;判断e的第一个参数是否是原子，是就输出yes&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun f2(e)
  (cond
    ((atom (car e)) (format t &amp;quot;yes&amp;quot;))))

&amp;gt;(f2 &#39;(a))
yes
nil

; 实现判断quote段

(defun f2 (e)
  (cond
    ((atom (car e)) (eq &#39;quote (car e)))))

&amp;gt;(f2 &#39;(quote))
T
&amp;gt;(f2 &#39;(eq))
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，按照代码上，如果等于参数e第一个元素等于&lt;code&gt;quote&lt;/code&gt;，应该是返回e的第二个元素，参见代码&lt;code&gt;((eq (car e) &#39;quote) (cadr e))&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun f2 (e)
  (cond
    ((atom (car e))
     (cond ((eq (car e) &#39;quote) (cadr e))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们可以看到，当e的第一个元素是quote的时候，会返回其后面的元素&amp;lt;即e的第二个元素&amp;gt;，但是第三个元素好像没有处理，先不管，接下来我们试试将第一段和本段合并，然后测试看看,我们合并的方法就不用f了，统一叫eval2,因为系统存在了eval函数所以我们重命名为eval2&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun eval2 (e a)
  (cond
    ((atom e) (assoc2 e a))
    ((atom (car e))
     (cond ((eq (car e) &#39;quote) (cadr e))))))

&amp;gt;(eval2 &#39;b &#39;((a 111) (b 222)))
222
&amp;gt;(eval2 &#39;(quote qq) ())
qq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成，除了第二段判断quote能看得出有些意义，看不懂第一个有什么意义，应该和后面递归有关系的
2014-05-04 03:16:24&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;先简单的分析下至此的代码，eval2接受2个参数，暂时我还不能准确的定义它们到底有什么用，可能看完了这个代码也不能确定吧
但是至此的代码我们可以看得出，e传入的值应该是原子的话，就将a中值等于e的元素的后一位元素返回，如 (eval2 &amp;lsquo;a &amp;lsquo;((a 1) (b 2))) =&amp;gt; 1,在此其实是规定了当e为原子的时候我们该做什么，同时也规定了当参数e为原子的时候，a就必须是((x 返回值1) (y 返回值2)…)的格式，否则会出错
接着，如果e不是原子，那么就是列表啦，接下来的代码是进行一堆判断，分别将列表e中第一个元素即(car e)和七个基本操作符进行eq判断，执行相应的操作，那么到此我们只实现了判断(car e)是否等于quote，是的话就返回e的第二个元素，如(eval2 &amp;lsquo;(quote qq) ()) =&amp;gt; qq,这就根据quote的特性，返回qq
2014-05-06 01:26:13&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;((eq (car e) &amp;lsquo;eq) (eq (eval2 (cadr e) a) (eval2 (caddr e) a)))
看了前面那么多，现在可以一眼看出，当e的第一个元素为eq的时候，将第二第三个元素进行eq比较，并返回&lt;/p&gt;

&lt;p&gt;((eq (car e) &amp;lsquo;car) (car (eval2 (cadr e) a)))
当e的第一个元素为car的时候，对e的第二个元素进行car操作,即(car (cadr e))&lt;/p&gt;

&lt;p&gt;((eq (car e) &amp;lsquo;cdr) (cdr (eval2 (cadr e) a)))
当e的第一个元素为cdr的时候，对e的第二个元素进行cdr操作,即(cdr (cadr e))&lt;/p&gt;

&lt;p&gt;((eq (car e) &amp;lsquo;cons) (cons (eval2 (cadr e) a) (eval2 (caddr e) a)))
当e的第一个元素为cons的时候，对e的第二,第三个元素进行cons操作,即(cons (cadr e) (caddr e))&lt;/p&gt;

&lt;p&gt;至此，第二段代码就只剩下最后一个比较复杂的小节啦，在第二段这里，我们需要清楚的明白这七个操作符的作用，而且这里的具体实现都用到的是它们本身，我们需要做的只是取出其后面的元素而已(使用eval2),总结起来整段代码都不算很复杂，可以这么理解
如果e元素1等于xxx,返回(xxx e元素2 [e元素3])&lt;/p&gt;

&lt;p&gt;2014-05-09 02:22:27&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;接下来的是cond,第一个元素是&lt;code&gt;cond&lt;/code&gt;,执行&lt;code&gt;(evcon (cdr e) a)&lt;/code&gt;，那么就是将去掉e中的第一个元素，传入&lt;code&gt;evcon&lt;/code&gt;，我们看一下&lt;code&gt;evcon&lt;/code&gt;函数的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun evcon (c a)
  (cond ((eval2 (caar c) a)
         (eval2 (cadar c) a))
    (&#39;t (evcon (cdr c) a))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出&lt;code&gt;evcon&lt;/code&gt;的作用是，调用&lt;code&gt;eval2&lt;/code&gt;得到第一个的第一个元素&lt;code&gt;(eval2 (caar c) a)&lt;/code&gt;是否是&lt;code&gt;T&lt;/code&gt;,是则执行其后面的值&lt;code&gt;(eval2 (cadar c) a)&lt;/code&gt;
否则就将去掉&lt;code&gt;c&lt;/code&gt;的第一个元素然后传入&lt;code&gt;(evcon (cdr c) a)&lt;/code&gt;, &lt;code&gt;evcon&lt;/code&gt;可以这么理解，它实现对参数以&lt;code&gt;cond&lt;/code&gt;语法规定的方式进行处理，其中使用&lt;code&gt;eval2&lt;/code&gt;函数来求值
用几个例子来了解&lt;code&gt;evcon&lt;/code&gt;函数的处理
首先我们写一句&lt;code&gt;cond&lt;/code&gt;语句
&lt;code&gt;(cond ((&amp;lt; 1 2) (quote a)))&lt;/code&gt; =&amp;gt; A
上面第一个元素是&lt;code&gt;cond&lt;/code&gt;，那么首先会对&lt;code&gt;(&amp;lt; 1 2)&lt;/code&gt;求值，如果是&lt;code&gt;T&lt;/code&gt;，执行&lt;code&gt;(quote a)&lt;/code&gt;，很明显1是小于2的，那么执行&lt;code&gt;(quote a)&lt;/code&gt;，返回A
接下来复杂一点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(cond ((&amp;lt; 1 0) (quote a))
  ((&amp;lt; 1 2) (quote b)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，首先取得&lt;code&gt;(&amp;lt; 1 0)&lt;/code&gt;的值为&lt;code&gt;nil&lt;/code&gt;(假)，那么不会执行后面的&lt;code&gt;(quote a)&lt;/code&gt;，然后取得&lt;code&gt;(&amp;lt; 1 2)&lt;/code&gt;的值为&lt;code&gt;T&lt;/code&gt;,执行&lt;code&gt;b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那么我们现在写的是一个lisp解释器，那么我们的eval2函数能够解释并执行上面的两个&lt;code&gt;cond&lt;/code&gt;语句的(==这里存在错误的地方,当时阻碍了我对代码的理解,后面会提到==)
我们将语句代入&lt;code&gt;eval2&lt;/code&gt;函数是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(eval2 &#39;(cond ((&amp;lt; 1 2) (quote a))) nil)

=&amp;gt; (evcon (cdr &#39;(cond ((&amp;lt; 1 2) (quote a)))) nil) ;根据((eq (car e) &#39;cond)  (evcon (cdr e) a))的定义

=&amp;gt; (evcon (((&amp;lt; 1 2) (quote a))) nil) ;这里要理解(cdr &#39;(cond ((&amp;lt; 1 2) (quote a)))) =&amp;gt; (((&amp;lt; 1 2) (quote a)))

=&amp;gt; (cond ((eval2 (caar (((&amp;lt; 1 2) (quote a)))) nil) ;这里到了evcon函数内部，我将代表的列表传了进来
          (eval2 (cadar (((&amp;lt; 1 2) (quote a)))) nil))
     (&#39;t (evcon (cdr (((&amp;lt; 1 2) (quote a)))) nil))))

=&amp;gt; (cond ((eval2 (&amp;lt; 1 2) nil) ;由此我们看到了当evcon是将参数里面的判断真假值的部分求值然后，T的部分求值返回
          (eval2 (quote a) nil)) ;而求值我们是使用eval2函数求值
     (&#39;t (evcon nil nil)))

=&amp;gt; (eval2 (quote a) nil) ;按照我们推测，结果是执行(eval2 (quote a))那么得出的结果自然是A
=&amp;gt; A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在试着将更复杂的&lt;code&gt;cond&lt;/code&gt;语句放入我们的eval2函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(eval2 &#39;(cond ((&amp;lt; 1 0) (quote a)) ((&amp;lt; 1 2) (quote b))) nil)
=&amp;gt; (evcon (cdr &#39;(cond ((&amp;lt; 1 0) (quote a)) ((&amp;lt; 1 2) (quote b))) nil)
=&amp;gt; (evcon (((&amp;lt; 1 0) (quote a)) ((&amp;lt; 1 2) (quote b))) nil)
=&amp;gt; (cond ((eval2 (caar (((&amp;lt; 1 0) (quote a)) ((&amp;lt; 1 2) (quote b)))) nil)
          (eval2 (cadar (((&amp;lt; 1 0) (quote a)) ((&amp;lt; 1 2) (quote b)))) nil))
         (&#39;t (evcon (cdr (((&amp;lt; 1 0) (quote a)) ((&amp;lt; 1 2) (quote b)))) nil)))
=&amp;gt; (cond ((eval2 (&amp;lt; 1 0) nil)                ;在这里我们可以看出当第一个元素的条件不成立，它会使用evcon去计算剩余的参数
          (eval2 (quote a) nil))            ;这样也就达到了cond根据条件是否执行接下来代码的部分
         (&#39;t (evcon (((&amp;lt; 1 2) (quote b))) nil)))
=&amp;gt; (evcon (((&amp;lt; 1 2) (quote b))) nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…以下是什么的重复了，把参数代入计算即可&lt;/p&gt;

&lt;p&gt;当你执行上面写的代码的时候会发现出现问题，其原因是里面存在了&lt;code&gt;(eval2 (&amp;lt; 1 2))&lt;/code&gt;这样的代码，我们的lisp解释器到底实现了什么，它到目前为止，只是能解析
&lt;code&gt;quote,atom,eq,car,cdr,cons,cond&lt;/code&gt;
当&lt;code&gt;eval2&lt;/code&gt;遇到&amp;lt;的时候，&lt;code&gt;(&amp;lt; 1 2)&lt;/code&gt;并不能得到一个真或假，我们可以使用非空列表或t表示真，那么就把其中求真求真假部分简单的用nil或t代替吧&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(eval2 &#39;(cond (&#39;t (quote a))) nil)
A

(eval2 &#39;(cond (&#39;nil (quote a)) (&#39;t (quote b))) nil)
B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好的，这一部分将近看完了，还剩下最后一小段代码了，这里需要注意的是，这里的&lt;code&gt;evcon&lt;/code&gt;函数并没有对&lt;code&gt;nil&lt;/code&gt;进行处理，当所有的条件都不为&lt;code&gt;T&lt;/code&gt;的时候，将会陷入死循环，无限的调用&lt;code&gt;(evcon nil nil)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2014-05-11 19:05:10&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;第一段的最后一句，当&lt;code&gt;e&lt;/code&gt;的第一个元素不为上述基本操作符的时候，那么会以&lt;code&gt;e&lt;/code&gt;的第一个元素为条件，从&lt;code&gt;a&lt;/code&gt;中获取对应的值，此时我们应该清楚了&lt;code&gt;a&lt;/code&gt;的作用了，我们称它为上下文吧，我们需要&lt;code&gt;a&lt;/code&gt;以&lt;code&gt;((属性1 值1) (属性2 值2) (属性3 值3)….)&lt;/code&gt;的方式保存值，使用&lt;code&gt;assoc2&lt;/code&gt;函数根据属性获取值
在最后这段代码，因为到这步，就表示e的第一个元素不是上面的操作符，所以以&lt;code&gt;e&lt;/code&gt;的第一个元素为属性，从&lt;code&gt;a&lt;/code&gt;里面获取值，然后再加上&lt;code&gt;(cdr e)&lt;/code&gt;构成新列表，新列表同样使用&lt;code&gt;eval2&lt;/code&gt;解析
如下例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(eval2 &#39;(qq a b c) &#39;((qq quote)))
=&amp;gt; (eval2 (cons (assoc2 (car (qq a b c)) ((qq quote)))
                        (cdr (qq a b c)))
            ((qq quote)))
=&amp;gt; (eval2 (cons (assoc2 qq ((qq quote)))
                     (a b c))
           ((qq quote)))
=&amp;gt; (eval2 (cons quote  (a b c)) ((qq quote)))
=&amp;gt; (eval2 (quote a b c) ((qq quote)))
=&amp;gt; (eval2 (quote a b c))            ;因为qq不属于上面定义的任何一个基本操作符，所以
=&amp;gt; (quote a)
=&amp;gt; A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一段解释完毕&lt;/p&gt;

&lt;p&gt;由于后面的代码是解析&lt;code&gt;label&lt;/code&gt;和&lt;code&gt;lambda&lt;/code&gt;，对此不熟悉，暂时不看代码了，转而继续学习Lisp，哪天再回头看看
2014-5-22 0:03:16&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;;;; 完整源代码
(defun assoc2 (x y)
  (cond ((eq (caar y) x) (cadar y))
        (t (assoc x (cdr y)))))

(defun eval2 (e a)
  (cond
    ((atom e) (assoc2 e a))
    ((atom (car e))
     (cond
       ((eq (car e) &#39;quote) (cadr e))
       ((eq (car e) &#39;atom)  (atom   (eval2 (cadr e) a)))
       ((eq (car e) &#39;eq)    (eq     (eval2 (cadr e) a)
                                    (eval2 (caddr e) a)))
       ((eq (car e) &#39;car)   (car    (eval2 (cadr e) a)))
       ((eq (car e) &#39;cdr)   (cdr    (eval2 (cadr e) a)))
       ((eq (car e) &#39;cons)  (cons   (eval2 (cadr e) a)
                                    (eval2 (caddr e) a)))
       ((eq (car e) &#39;cond)  (evcon (cdr e) a))))))
       

(defun evcon (c a)
  (cond ((eval2 (caar c) a)
         (eval2 (cadar c) a))
        (&#39;t (evcon (cdr c) a))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/suiqirui19872005/archive/2007/12/05/984517.html&#34;&gt;过河卒的Lisp入门&lt;/a&gt; 
&lt;a href=&#34;http://zh.wikibooks.org/wiki/Lisp_%E5%85%A5%E9%96%80&#34;&gt;维基教科书Lisp入门&lt;/a&gt; &lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于浮点数的二进制表示的思考</title>
      <link>/posts/about-binary/</link>
      <pubDate>Tue, 28 Jun 2016 10:11:58 +0000</pubDate>
      
      <guid>/posts/about-binary/</guid>
      <description>

&lt;h3 id=&#34;科学计数法&#34;&gt;科学计数法&lt;/h3&gt;

&lt;p&gt;在谈论浮点数表示形式之前，我们先看看，如何用科学计数法表示一个实数, 如&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;$123 = 1.23 * 10^2$&lt;/p&gt;

&lt;p&gt;$45.6=4.56 * 10^1$&lt;/p&gt;

&lt;p&gt;$-0.789 = -7.89 * 10^{-1}$&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这里我们可以找出下列数据&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数字&lt;/th&gt;
&lt;th&gt;尾数&lt;/th&gt;
&lt;th&gt;指数&lt;/th&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;123&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;正&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;45.6&lt;/td&gt;
&lt;td&gt;56&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;正&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-78.9&lt;/td&gt;
&lt;td&gt;789&lt;/td&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;负&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;浮点数各位的大小&#34;&gt;浮点数各位的大小&lt;/h3&gt;

&lt;p&gt;相比整数，浮点数的二进制表示稍显复杂,根据IEEE-754标准规定，浮点数表示分3部分&lt;/p&gt;

&lt;p&gt;&lt;code&gt;符号&lt;/code&gt;，&lt;code&gt;指数&lt;/code&gt;和&lt;code&gt;尾数&lt;/code&gt;，之所以开始提到科学计数法，原因就在此，浮点数的表示就是基于科学计数法的形式存储&lt;/p&gt;

&lt;p&gt;其占位数(2进制位)分别如下&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;符号(S)&lt;/th&gt;
&lt;th&gt;指数(E)&lt;/th&gt;
&lt;th&gt;尾数(M)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单精度 (float)&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;双精度 (double)&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;那么我们可以看到，单精度和双精度的数字在内存中的表示如下 &lt;code&gt;(S符号位 E指数 M尾数)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 单精度 (总32位)
S(1) EEEEEEEE(8) MMMMMMMMMMMMMMMMMMMMMMM(23)
# 双精度 (总64位)
S(1) EEEEEEEEEEE(11) MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM(52)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;浮点数转换为二进制&#34;&gt;浮点数转换为二进制&lt;/h3&gt;

&lt;p&gt;我们已经知道了一个浮点数在内存中的分布情况，那么我们现在可以开始尝试将一个浮点数转换为二进制&lt;/p&gt;

&lt;p&gt;我们需要分别将&lt;code&gt;符号&lt;/code&gt;,&lt;code&gt;指数&lt;/code&gt;,&lt;code&gt;尾数&lt;/code&gt;分别转换&lt;/p&gt;

&lt;h4 id=&#34;1-转换符号&#34;&gt;1.转换符号&lt;/h4&gt;

&lt;p&gt;符号位这个没什么好说，0表示正，1表示负&lt;/p&gt;

&lt;h4 id=&#34;2-找到指数和尾数&#34;&gt;2.找到指数和尾数&lt;/h4&gt;

&lt;p&gt;如何将小数转换二进制一开始是我无法理解的地方，直到我这样看待一个二进制数字&lt;/p&gt;

&lt;p&gt;$11.111 = (1*2^{1}) + (1*2^{0}) + (1*2^{-1}) +( 1*2^{-2}) +( 1*2^{-3})$&lt;/p&gt;

&lt;p&gt;$0.1&lt;em&gt;{(2)} ＝ 0.5&lt;/em&gt;{(10)}$&lt;/p&gt;

&lt;p&gt;$0.11&lt;em&gt;{(2)} ＝(1*2^{-1}) + (1*2^{-2}) ＝ 0.75&lt;/em&gt;{(10)}$&lt;/p&gt;

&lt;p&gt;一个数字12.5，将其整数部分和小数部分分别转换为2进制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;12.5 = 1100.1
# 整数
12 = &amp;gt; 1100
# 小数
0.5 =&amp;gt; 0.1    # 2的-1次方 = 0.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们将1100.1转换为科学计数法表示: ($1.xxx * 2^n$)&lt;/p&gt;

&lt;p&gt;$1100.1 = 1.1001 * 2^{3}$&lt;/p&gt;

&lt;p&gt;左移位数为正，右移位数为负&lt;/p&gt;

&lt;p&gt;得出尾数 ＝ 1001， 指数＝3&lt;/p&gt;

&lt;p&gt;这里需要注意，尾数位数如果超出，需要截断&lt;/p&gt;

&lt;h4 id=&#34;3-指数转换为二进制&#34;&gt;3.指数转换为二进制&lt;/h4&gt;

&lt;p&gt;指数部分使用余127码(float)或余1023码(double)表示&lt;/p&gt;

&lt;p&gt;余127码就是值加上127，余1023码就是值加上1023，如下&lt;/p&gt;

&lt;p&gt;数字的余127码 ＝ 值 ＋ 127&lt;/p&gt;

&lt;p&gt;数字的余1023码＝ 值 ＋ 1023&lt;/p&gt;

&lt;p&gt;float的指数位为8位，其值的范围为 -127 ~ 128, float的指数位使用余127码表示&lt;/p&gt;

&lt;p&gt;double的指数位为11位，其值的范围为 -1023 ~ 1024, float的指数位使用余1023码表示&lt;/p&gt;

&lt;p&gt;这样做使得指数就不存在处理负数的问题,其值直接存为无符号整数的二进制形式，因为无论是-127的余127码＝0，-1023的余1023码＝0&lt;/p&gt;

&lt;p&gt;这样在内存中，指数的最小值为0，二进制表示即为&lt;code&gt;00000000(float)&lt;/code&gt;或&lt;code&gt;00000000000(double)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例如一个float指数为3， 那么其指数的二进制在内存中表示为130的二进制&lt;/p&gt;

&lt;p&gt;一个double指数为3，那么其指数的二进制在内存中表示为1026的二进制&lt;/p&gt;

&lt;h5 id=&#34;一个简单的小数转换为二进制的方法&#34;&gt;一个简单的小数转换为二进制的方法&lt;/h5&gt;

&lt;p&gt;如果是float，其尾数是23位，那么我们将其小数位*$2^{23}$,然后将其整数转换为二进制即可，double就是$2^{52}$，注意尾数长度问题，超出截断即可&lt;/p&gt;

&lt;h4 id=&#34;浮点数转换示例&#34;&gt;浮点数转换示例&lt;/h4&gt;

&lt;h5 id=&#34;float-18-765&#34;&gt;float: 18.765&lt;/h5&gt;

&lt;p&gt;将其转换为二进制＝ 10010.10011001100110011001100，将其转换为科学计数法&lt;/p&gt;

&lt;p&gt;$1.001010011001100110011001100 * 2^4$&lt;/p&gt;

&lt;p&gt;指数转换为二进制，$4+127 ＝ 131 ＝ 10000011_{(2)}$&lt;/p&gt;

&lt;p&gt;那么得出符号位＝0，指数＝&lt;code&gt;10000011&lt;/code&gt;，尾数＝&lt;code&gt;001010011001100110011001100&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那么其在内存表示为&lt;/p&gt;

&lt;p&gt;&lt;code&gt;010000011001010011001100110011001100&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;float-20-33&#34;&gt;float:-20.33&lt;/h5&gt;

&lt;p&gt;将其转换为二进制 ＝ 10100.0101010001111010111，将其转换为科学计数法&lt;/p&gt;

&lt;p&gt;$1.01000101010001111010111 * 2^4$&lt;/p&gt;

&lt;p&gt;指数转换为二进制 4+127 ＝ 131 ＝&amp;gt; 10000011&lt;/p&gt;

&lt;p&gt;那么得出符号位＝1，指数＝&lt;code&gt;10000011&lt;/code&gt;，尾数＝&lt;code&gt;01000101010001111010111&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那么其在内存表示为&lt;/p&gt;

&lt;p&gt;11000001101000101010001111010111&lt;/p&gt;

&lt;h5 id=&#34;double-341-95&#34;&gt;double: 341.95&lt;/h5&gt;

&lt;p&gt;将其转换为二进制101010101.111100110011001100110011001100110011001100110011001，将其转换为科学计数法&lt;/p&gt;

&lt;p&gt;$1.0101010111110011001100110011001100110011001100110011 * 2^8$&lt;/p&gt;

&lt;p&gt;指数转换为二进制 8+1023 ＝ 1031 ＝&amp;gt; 10000000111&lt;/p&gt;

&lt;p&gt;那么得出符号位＝0，指数＝&lt;code&gt;10000000111&lt;/code&gt;，尾数＝&lt;code&gt;0101010111110011001100110011001100110011001100110011&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那么其在内存表示为&lt;/p&gt;

&lt;p&gt;0100000001110101010111110011001100110011001100110011001100110011&lt;/p&gt;

&lt;h4 id=&#34;一个打印二进制数的函数&#34;&gt;一个打印二进制数的函数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void printbin(unsigned long x, int n) {
    if (--n) printbin(x&amp;gt;&amp;gt;1, n);
    putchar(&amp;quot;01&amp;quot;[x&amp;amp;1]);
}

//调用示例
// 打印float
float f = -40.34;
printbin(*(int *)&amp;amp;f, sizeof(float)*8);
// 打印double
double d = -40.34d;
printbin(*(long *)&amp;amp;d, sizeof(double)*8);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;参考&lt;/p&gt;

&lt;p&gt;《计算机科学导论第3章》&lt;/p&gt;

&lt;p&gt;博文：&lt;a href=&#34;http://www.cnblogs.com/bossin/archive/2007/04/08/704567.html&#34;&gt;IEEE 754 浮点数的表示精度探讨&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>整数的表示，关于原码，反码和补码的思考</title>
      <link>/posts/about-integer/</link>
      <pubDate>Tue, 21 Jun 2016 14:00:27 +0000</pubDate>
      
      <guid>/posts/about-integer/</guid>
      <description>

&lt;p&gt;整数分为&lt;code&gt;有符号整数&lt;/code&gt;和&lt;code&gt;无符号整数&lt;/code&gt;,其实就是通常意义下的&lt;code&gt;正整数&lt;/code&gt;和&lt;code&gt;负整数&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;为了简单起见，这里的数字使用4位二进制表示，这样数的范围不会太大(这样我就不用列大大的表格啦)。&lt;/p&gt;

&lt;h2 id=&#34;无符号整数&#34;&gt;无符号整数&lt;/h2&gt;

&lt;p&gt;无符号整数的表示比较简单，直接将其转换为二进制即可，如&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数字&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;二进制&lt;/td&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;0100&lt;/td&gt;
&lt;td&gt;0101&lt;/td&gt;
&lt;td&gt;0110&lt;/td&gt;
&lt;td&gt;0111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数字&lt;/th&gt;
&lt;th&gt;8&lt;/th&gt;
&lt;th&gt;9&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;11&lt;/th&gt;
&lt;th&gt;12&lt;/th&gt;
&lt;th&gt;13&lt;/th&gt;
&lt;th&gt;14&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;二进制&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;td&gt;1010&lt;/td&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;td&gt;1100&lt;/td&gt;
&lt;td&gt;1101&lt;/td&gt;
&lt;td&gt;1110&lt;/td&gt;
&lt;td&gt;1111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;有符号整数&#34;&gt;有符号整数&lt;/h2&gt;

&lt;h4 id=&#34;原码表示&#34;&gt;原码表示&lt;/h4&gt;

&lt;p&gt;原码通过分配一个最高位用于表示数字的正负，其余位数表示数值，相应值如下&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数字&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原码&lt;/td&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;0100&lt;/td&gt;
&lt;td&gt;0101&lt;/td&gt;
&lt;td&gt;0110&lt;/td&gt;
&lt;td&gt;0111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数字&lt;/th&gt;
&lt;th&gt;-0&lt;/th&gt;
&lt;th&gt;-1&lt;/th&gt;
&lt;th&gt;-2&lt;/th&gt;
&lt;th&gt;-3&lt;/th&gt;
&lt;th&gt;-4&lt;/th&gt;
&lt;th&gt;-5&lt;/th&gt;
&lt;th&gt;-6&lt;/th&gt;
&lt;th&gt;-7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原码&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;td&gt;1010&lt;/td&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;td&gt;1100&lt;/td&gt;
&lt;td&gt;1101&lt;/td&gt;
&lt;td&gt;1110&lt;/td&gt;
&lt;td&gt;1111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;虽然原码看起来比较简单，但是其存在2个0，更重要的是使用原码进行加法运算也不会得到正确的结果，不信你看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 1 + (-1)
0001 + 1001 =&amp;gt; 1010 =&amp;gt; -2
# 1 + (-3)
0001 + 1011 =&amp;gt; 1100 =&amp;gt; -4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;反码表示&#34;&gt;反码表示&lt;/h4&gt;

&lt;p&gt;反码就是在原码的基础上，将正数各位取反获得负数反码，正数的反码就是它二进制值本身,如下表&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数字&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;反码&lt;/td&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;0100&lt;/td&gt;
&lt;td&gt;0101&lt;/td&gt;
&lt;td&gt;0110&lt;/td&gt;
&lt;td&gt;0111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数字&lt;/th&gt;
&lt;th&gt;-0&lt;/th&gt;
&lt;th&gt;-1&lt;/th&gt;
&lt;th&gt;-2&lt;/th&gt;
&lt;th&gt;-3&lt;/th&gt;
&lt;th&gt;-4&lt;/th&gt;
&lt;th&gt;-5&lt;/th&gt;
&lt;th&gt;-6&lt;/th&gt;
&lt;th&gt;-7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;反码&lt;/td&gt;
&lt;td&gt;1111&lt;/td&gt;
&lt;td&gt;1110&lt;/td&gt;
&lt;td&gt;1101&lt;/td&gt;
&lt;td&gt;1100&lt;/td&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;td&gt;1010&lt;/td&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;反码解决原码中计算加法的时候数值不正确的问题,但是它还存在有2个0的问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 1 + (-1)
0001 + 1110 =&amp;gt; 1111 =&amp;gt; 0
# 1+ (-7)
0001 + 1000 =&amp;gt; 1001 =&amp;gt; -6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;补码表示&#34;&gt;补码表示&lt;/h2&gt;

&lt;p&gt;补码在反码的基础＋1，其实就是 负整数(补码) ＝ 正整数(反码)＋1。 (注意丢弃溢出位)&lt;/p&gt;

&lt;p&gt;或者说 负整数(补码) ＝ 正整数按位取反 ＋ 1, (注意丢弃溢出位)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数字&lt;/th&gt;
&lt;th&gt;0&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;th&gt;7&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;补码&lt;/td&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;td&gt;0010&lt;/td&gt;
&lt;td&gt;0011&lt;/td&gt;
&lt;td&gt;0100&lt;/td&gt;
&lt;td&gt;0101&lt;/td&gt;
&lt;td&gt;0110&lt;/td&gt;
&lt;td&gt;0111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数字&lt;/th&gt;
&lt;th&gt;-1&lt;/th&gt;
&lt;th&gt;-2&lt;/th&gt;
&lt;th&gt;-3&lt;/th&gt;
&lt;th&gt;-4&lt;/th&gt;
&lt;th&gt;-5&lt;/th&gt;
&lt;th&gt;-6&lt;/th&gt;
&lt;th&gt;-7&lt;/th&gt;
&lt;th&gt;-8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;补码&lt;/td&gt;
&lt;td&gt;1111&lt;/td&gt;
&lt;td&gt;1110&lt;/td&gt;
&lt;td&gt;1101&lt;/td&gt;
&lt;td&gt;1100&lt;/td&gt;
&lt;td&gt;1011&lt;/td&gt;
&lt;td&gt;1010&lt;/td&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;补码解决了反码中有2个0的问题，成为最合适用来表示整数的表示方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 1 + (-1)
0001 + 1111 =&amp;gt; 1,0000(丢弃溢出位) ＝&amp;gt; 0
# 1 + (-7)
0001 + 1001 =&amp;gt; 1010 =&amp;gt; -6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;无论原码，反码还是补码，他们在表示正整数的时候都是一样的，其不同之处在于负整数表示。&lt;/p&gt;

&lt;p&gt;而顺着下来看，它们的出现其实就是针对用二进制表示有符号整数这一问题的解决方案的演进。只要了解了这一点，也就不会被它们的弄晕了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>vim的简单配置</title>
      <link>/posts/vim-config/</link>
      <pubDate>Sat, 04 Jun 2016 17:04:13 +0000</pubDate>
      
      <guid>/posts/vim-config/</guid>
      <description>

&lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;

&lt;p&gt;我对vi的使用上没什么挑剔的,毕竟多数是在写小程序上使用的
默认的vi其实也够用了不过还是为了增加使用vi时的编码效率还是弄些插件,改改默认配置,在此做个记录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;syntax on       &amp;quot; 语法高亮

set autoindent  &amp;quot; 自动对齐,把当前行的对起格式应用到下一行
set smartindent &amp;quot; 智能的选择对起方式
set smartindent &amp;quot; 开启新行时使用智能自动缩进
set tabstop=4   &amp;quot; 设置tab键为4个空格, 默认8,
set shiftwidth=4&amp;quot; 将换行自动缩进设置成4个空格


set cursorline  &amp;quot; 横线指示当前行

set ruler       &amp;quot; 打开状态栏标尺

set incsearch   &amp;quot; 输入搜索内容时就显示搜索结果
set hlsearch    &amp;quot; 搜索时高亮显示被找到的文本

set showmatch   &amp;quot; 插入括号时，短暂地跳转到匹配的对应括号

set laststatus=2 &amp;quot;显示状态栏 (默认值为 1, 无法显示状态栏)
set cmdheight=1 &amp;quot; 显示状态栏 (默认值为 1, 无法显示状态栏)
&amp;quot; 设置在状态行显示的信息
set statusline=\ %&amp;lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&amp;amp;fileformat}\ %{&amp;amp;encoding}\ %c:%l/%L%)


&amp;quot;普通状态下输入f即可打印出function定义
nnoremap f ofunction () {&amp;lt;ENTER&amp;gt;&amp;lt;ESC&amp;gt;i}&amp;lt;ESC&amp;gt;kwi
&amp;quot; 这样分号键就可以进入命令行模式
nnoremap ; :

inoremap ( ()&amp;lt;ESC&amp;gt;i
inoremap [ []&amp;lt;ESC&amp;gt;i
inoremap &amp;quot; &amp;quot;&amp;quot;&amp;lt;ESC&amp;gt;i
inoremap { {}&amp;lt;ESC&amp;gt;i
&amp;quot;输入(&amp;quot;时补全&amp;quot;);
inoremap (&amp;quot; (&amp;quot;&amp;quot;);&amp;lt;ESC&amp;gt;hhi
inoremap then thenend&amp;lt;ESC&amp;gt;hhi&amp;lt;ENTER&amp;gt;&amp;lt;BACKSPACE&amp;gt;&amp;lt;ESC&amp;gt;ko
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;添加颜色主题&#34;&gt;添加颜色主题&lt;/h3&gt;

&lt;p&gt;关于颜色主题这个不影响使用,但是在实际在linux上使用发现蓝色比较难看清,索性就找找颜色主题替换算了
vim的颜色主题很好修改,在配置文件里面添加 colorscheme 主题名称 就行了
至于主题可以到vim官网或github找
&lt;a href=&#34;http://www.vim.org/scripts/script.php?script_id=625&#34;&gt;http://www.vim.org/scripts/script.php?script_id=625&lt;/a&gt;
下载之后将文件存放在~/.vim/colors, 配置文件上加上&lt;code&gt;colorscheme 主题名称&lt;/code&gt;(其实就是主题的文件名)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>王爽-汇编语言学习感想</title>
      <link>/posts/about-asm/</link>
      <pubDate>Sun, 29 May 2016 23:08:52 +0000</pubDate>
      
      <guid>/posts/about-asm/</guid>
      <description>&lt;p&gt;不知道什么时候开始,我有个习惯,就是在书上标注购买时间,这样我会知道我的每一本书的购买日期,当我再次拿起书本时,我知道,原来它已经陪伴了我这么久,但我却不懂得珍惜,以致于现在我还没看完.&lt;/p&gt;

&lt;p&gt;我购买的王爽的汇编语言是11年12月11日,距今差不多5年了,然而我还是没能看完这本最简单的汇编入门书,而时光一晃,几年过去了,我却什么也没学到,最大原因还是自身的浮躁.&lt;/p&gt;

&lt;p&gt;一开始我就有着许多不切实际的幻想,写操作系统,写游戏,写编译器等,也买上了许多书,认为我应该学习这个,应该学习那个,但最后都半途而废了,浪费了太多时间.&lt;/p&gt;

&lt;p&gt;从3月份开始,我开始重新对本书的学习,花了2个月的时间,我把书中几乎所有的程序都实现了一遍,当然也有疑惑,只是我不大想深究,我最终的目的是想对C,汇编,操作系统有个全局的了解,然后写一个极小的操作系统,之后再干嘛我已经不想计划了,单单这个过程我想至少会消耗我1年甚至更长的时间,我能不能坚持下来已经是个问题,我不能再给自己太多的选择了,因为我看到了我4年多的时间是如何浪费的.&lt;/p&gt;

&lt;p&gt;最后,摘录一些其他领域我摘录下来的语句送给自己以及正在阅读这篇文章的朋友,我相信,知识在一定程度内是相通的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;复利原理就是普世大道&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要执迷于某个数字的多少次方后边的结果，那只是点燃内心欲望，让人自迷的表象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;复利原理，要表达的意思是：复利周期内看似不起眼的小进步或者小退步，假以时日，则会让本体产生超乎想象的巨大进步或者退步&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要高估你一年能做成的事, 也不要低估你五年能做成的事&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
